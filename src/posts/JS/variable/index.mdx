---
title: '자바스크립트의 변수'
date: '2023-01-28T21:45:03.284Z'
description: '변수에 대해서 알아보자'
category: 'JS'
---

![](./js.png)

# 변수란 무엇인가

애플리케이션은 데이터를 다룬다. 변수는 프로그래밍 언어에서 데이터를 관리하기 위한 핵심 개념이다.

## 사람과 컴퓨터의 연산방법

`10 + 20` 우리는 이 식을 어떻게 계산하는가?

10과 20 그리고 + 라는 기호를 알고있어야하고 10 + 20 이라는 식의 의미도 해석할 수 있어야한다.<br/>
10 + 20 식의 의미를 해석하려면 + 기호의 의미와 숫자 10, 20을 두뇌에 저장한다. 그리고 10과 20을 더한 결과인 30도 두뇌에 저장한다.

JS Engine도 사람과 유사하게 위의 코드를 실행한다.

JS Engine이 위 코드를 평가(evaluation)하려면 사람과 유사하게 리터럴(10,20)과 연산자(+)의 의미를 알고있어야하고 10 + 20 이라는 표현식(expression)의 의미도 파싱할 수 있어야한다.

JS Engine이 위의 식을 해석하려면 피연산자를 기억한고 메모리에 데이터를 기억한다.

## 메모리

메모리는 데이터를 저장할 수 있는 메모리 셀 집합체다. 메모리 셀 하나의 크기는 1Byte 이고 1Byte 단위로 데이터를 저장하거 읽어 들인다.<br/>

각 셀은 고유의 메모리 주소를 갖는다. 메모리 주소는 메모리 공간의 위치를 나타낸다.

컴퓨터는 모든 데이터를 2진수로 처리한다. 따라서 메모리에 저장된느 데이터는 종류에 상관없이 모두 2진수로 저장된다.<br/>
위 예제에서 숫자 10과 20은 임의의 메모리 위치에 저장되고 결과값인 30도 임의의 메모리에 위치하게된다.

성공적으로 연산이 끝났고 결과도 메모리에 저장이 되었지만 문제는 30이라는 값을 재사용하고 싶은것이다.

30이 저장된 메모리 주소를 통해 메모리 공간에 직접 접근하는것 외에는 방법이 없다.<br/>
하지만 메모리에 직접 접근하는 것은 치명적 오류를 발생시킬 가능성이 높다.

만약 자바스크립트 개발자의 직접적인 메모리 제어를 허용한다 해도 문제가 있다. 값이 저장되는 메모리 주손느 코드가 실행될때마다 상황에 따라 임의로 결정되기 때문이다. 메모리 주소를 알 수 있는 방법도 없으며 알려주지도 않는다.

이럴때에 저장된 값을 읽어 들여 재사용하기 위해 변수라는 개념이 등장한다.

> 변수는 값을 담고 있는 메모리 공간 자체 또는 그 메모리 공간의 주소를 가리키는 식별자이다. 변수에 값이 할당되면 실제로는 메모리 공간에 값이 담기고 변수는 그 메모리 주소를 가리킨다.

## 식별자

식별자는 어떤 값을 구별해서 식별할 수 있는 고유한 이름을 뜻한다.

변수의 이름을 식별자라고도 한다. <br/>
값은 메모리공간에 저장되어있다. 따라서 식별자는 메모리 공간에 저장되어 있는 어떤 값을 구별해서 식별할 수 있어야한다.

이를 위해 식별자는 어떤 값이 저장되어 있는 메모리 주소를 기억해야한다.

식별자라는 용어는 변수에만 사용하는게 아닌 함수, 클래스 등의 이름은 모두 식별자다. 메모리상에 존재하는 어떤 값을 식별할 수 있는 이름을 모두 식별자라고 부른다

식별자는 선언에 의해 JS Engine에게 존재를 알린다.

## 선언

선언이란 식별자를 생성하는 것을 말한다. 자세하게는 값을 저장하기 위한 메모리 공간을 확보하고 식별자 이름과 확보된 메모리 공간의 주소를 연결하여 값을 저장할 수 있게 준비하는것이다.

선언에 의해 확보된 메모리 공간은 확보가 해제되기 전까지는 누구도 확보된 메모리 공간을 사용할 수 없도록 보호되므로 안전하게 사용할 수 있다.

```js
const name = '안녕'
```

위 변수 선언문은 아래와 같이 변수 이름을 등록하고 값을 저장할 메모리 공간을 확보한다.

```
주소         메모리공간
0X000000F2  '안녕'
```

JS Engine은 변수 선언을 두단계에 거쳐 수행한다

-   선언 단계 : 변수 이름을 등록해서 엔진에게 존재를 알린다.
-   초기화 단계 : 메모리 공간을 확보하여 값을 저장한다.

var 키워드를 사용한 변수선언은 `선언 단계`와 `초기화 단계`가 동시에 진행된다. 선언단계를 통해 변수 이름을 등록하고 초기화 단계를 통해 값을 할당받았다면 값을 초기화하고 할당받지 못했다면 암묵적으로 undefined를 할당해 초기화한다.

만약 초기화 단계를 거치지 않으면 확보된 메모리 공간에는 이전에 다른 애플리케이션이 사용했던 값이 남아있을수 있다. <br/>
이러한 값을 Garbage value라고 한다.

따라서 값을 할당하지 않은 상태에서 곧바로 변수 값을 참조하면 Garbage value값이 나올 수 있다. var 키워드는 암묵적으로 초기화를 수행하므로 이런 위험으로부터 안전하다.

## 선언의 실행 시점

```js
console.log(score) // undefined

var score
```

자바스크립트 코드는 [인터프리터](http://www.ktword.co.kr/test/view/view.php?m_temp1=3071)\*에 의해 한줄씩 순차적으로 실행되므로 `console.log(score);`가 가장 먼저 실행되고 순차적으로 다음 줄에 있는 코드를 실행한다.

따라서 `console.log(score);`가 실행되는 시점에는 아직 score 변수가 선언 실행이 되지 않았으므로 참조에러가 발생할것처럼 보인다. 하지만 var 키워드를 사용했기때문에 에러는 발생하지 않고 undefined가 출력된다.

**그 이유는 변수 선언이 소스코드가 한 줄씩 순차적으로 실행되는 시점(런타임)이 아닌 그 이전 단게에서 먼저 실행되기 때문이다.**

JS Engine은 소스코드를 한 줄씩 순차적으로 실행하기 앞서 평가 과정을 거치며 실행하기 위한 준비를 한다.

이 단계에서 JS Engine은 변수 선언을 포함한 모든 선언문을 찾아내 먼저 실행한다. 그리고 평가 과정이 종료되면 모든 선언문을 제외하고 한 줄씩 순차적으로 실행한다.

JS Engine은 선언이 어디에 있든 상관없이 다른 코드보다 먼저 실행한다. 따라서 어디에 위치하던 상관없이 어디서든 변수를 참조할 수 있다.<br/>
위의 예제에서 score는 변수 선언이 되기 이전에 변수를 참조하는 코드인 `console.log(score);`가 앞에 있다.<br/>
만약 순차적으로 실행되는 런타임에 변수 선언이 실행된다면 변수 선언 이전이기 때문에 참조에러(Reference Error)가 발생했을것이다.

하지만 undefined가 출력되었다

**이는 변수선언(선언단계와 초기화단계)가 런타임 이전에 실행된다는 증거다**<br/>
위의 예제처럼 변수 선언문이 코드의 선두로 끌어 올려진 것처럼 동작하는 자바스크립트의 고유의 특징을 **호이스팅**이라 한다.

## 할당

```js
// 1번
var score // 변수 선언
score = 10 // 할당

// 2번
var score = 80 // 변수선언과 할당
```

선언과 할당을 두개의 문(statement)로 나누어 표현한 코드와 하나의 문으로 단축한 코드는 정확히 동일하게 동작한다.

JS Engine은 변수 선언과 값의 할당을 하나의 문으로 단축 표현해도 선언과 할당을 각각 나누어 수행한다.<br/>
여기서 주의해야하는 점은 선언과 할당의 실행 시점이 다르다는 것이다.

**변수 선언은 소스코드가 순차적으로 실행되는 시점인 런타임 이전에 실행되지만 할당은 런타임에 실행된다.**

```js
console.log(score) // undefined

var score = 80

console.log(score) // 80
```

선언은 런타임 이전에 실행되고 할당은 런타임에 실행된다. 따라서 할당하는 시점인 런타임에는 선언이 완료된 상태이며 이미 undefined로 초기화 되어있다. 따라서 새롭게 할당한 숫자 80으로 변경(할당)된다.

```
        메모리주소        값
선언     0x0000000F2    undefined
할당     0X0000000F3    80
```

주의할점은 이전 값 undefined가 저장되어 있던 메모리 공간을 지우고 그 메모리 공간에 새로운 값 80을 저장하는게 아닌, 새로운 메모리 공간을 확보하고 그곳에 할당된 값 80을 저장한다는것을 알아야한다.

**할당 혹은 재할당을 하면 메모리주소가 바뀌게 된다.**

재할당이 불가능한 변수를 **상수**라고한다.

**ES6**부터 도입된 `const` 키워드를 사용한 변수는 상수로써 사용이 가능하다. 하지만 상수만을 위해 사용되지는 않는다는것을 알아야한다.

위의 예에서 할당되어 어떤 변수도 값으로 갖고있지 않은 메모리주소 `0x000000F2`는 어떤 식별자와도 연결되어 있지 않다.

이러한 불필요한 값들은 [가비지 컬렉터](https://ko.javascript.info/garbage-collection)에 의해 메모리에서 자동 해제된다. **단 언제 해제될지는 예측할 수 없다**

> 가비지컬렉터는 애플리케이션이 할당한 메모리 공간을 주기적으로 검사하여 더 이상 사용하지 않는 메모리를 해제하는 기능을 뜻한다. 더이상 사용하지 않는 메모리란 어떤 식별자와도 참조하지 않는 메모리 공간을 말한다

## 값

지금까지 값이라는 용어를 많이 사용했다. 값(value)는 표현식이 평가되어 생성된 결과를 뜻한다.

모든 값은 데이터 타입을 가지고 메모리에 2진수로 저장된다.

변수는 **하나의 값**을 저장하기 위해 메모리 공간 자체 또는 그 메모리 공간을 식별하기 위해 사용되는 식별자라고 이야기했다. <br/>변수에 할당되는것이 값(value)다

### 리터럴

사람이 이해할 수 있는 문자 또는 약속된 기호법을 사용해 값을 생성하는 표기법을 **리터럴**이라 한다.

```js
3
```

예제의 3은 아라비아 숫자 3이 아닌 숫자 리터럴이다.

사람이 이해할 수 있는 아라비아 숫자를 사용해 숫자 리터럴 3을 기술하면 JS Engine은 이를 평가해 숫자 값 3을 생성한다.

### 표현식

값으로 평가될수 있는 문(statement)를 표현식이라 한다. 즉 표현식이 평가되면 새로운 값을 생성하거나 기존값을 참조하게 된다.

```js
var score = 50 + 50 // 1번

score // 2번
```

위의 예제에서 1번은 `50 + 50`은 숫자리터럴 `50`과 연산자 `+`과 숫자리터럴 `50`으로 이루어져있다. 이는 평가되어 숫자 값 100을 생성하므로 표현식이다.

2번에서 변수 식별자를 참조하면 변수 값으로 평가된다. 식별자 참조는 값을 생성하지는 않지만 값으로 평가되므로 표현식이다.

표현식은 리터럴, 식별자, 연산자, 함수 호출 등의 조합으로 이루어질수있다. 즉 값으로 평가될수 있는 모든 문(statement)은 표현식이다.

### 문

문(statement)은 프로그램을 구성하는 기본단위이자 최소 실행단위다.

문은 여러 토큰으로 구성되며 토큰은 문법정 의미를 가지며 문법적으로 더이상 나눌 수 없ㄴ는 코드의 기본 요소를 의미한다

표현식인 문과 표현식이 아닌 문이 존재한다.

표현식은 위에서 값으로 평가되는 식이라고 설명했다.

```js
var x // 1

x = 1 + 2 // 2
```

1번은 변수 선언문이다. 하지만 값으로 평가 될수는 없으므로 표현식이 아닌 문이고, 2번은 변수를 재할당하며 값으로 평가될수있기 때문에 표현식인 문이다.

표현식인 문과 표현식이 아닌 문을 구별하는 가장 간단한 방법은 변수에 할당해 보는 방법이다

#### 참조 레퍼런스

-   모던 자바스크립트 Deep Dive
